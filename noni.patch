Index: syscall.c
===================================================================
--- syscall.c	(revision 3)
+++ syscall.c	(working copy)
@@ -98,7 +98,12 @@
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_addpath(void);
+extern int sys_wait2(void);
+extern int sys_getPriority(void);
 
+
+
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
 [SYS_exit]    sys_exit,
@@ -121,6 +126,9 @@
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_addpath]  sys_addpath,
+[SYS_wait2] sys_wait2,
+[SYS_getPriority] sys_getPriority, 
 };
 
 void
Index: syscall.h
===================================================================
--- syscall.h	(revision 3)
+++ syscall.h	(working copy)
@@ -21,3 +21,6 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_addpath 22
+#define SYS_wait2 23
+#define SYS_getPriority 24
\ No newline at end of file
Index: exec.c
===================================================================
--- exec.c	(revision 3)
+++ exec.c	(working copy)
@@ -6,23 +6,59 @@
 #include "defs.h"
 #include "x86.h"
 #include "elf.h"
+#include "defs.h"
 
+#define MAX_PATH_ENTRIES  10
+#define INPUT_BUF 128
+char path_set[MAX_PATH_ENTRIES][INPUT_BUF];
+int path_num = 0;
+int 
+addpath(char* path)
+{
+  int j;
+  if(path_num  >= MAX_PATH_ENTRIES)
+    return -1;
+  for(j =0; j<path_num; j++)
+  {
+    if(strncmp( path_set[j], path, INPUT_BUF) == 0){
+      return -1;
+    }
+  }
+  strncpy(path_set[path_num],path,strlen(path));
+  path_num++;
+  
+  cprintf("%s  %d\n",path,path_num);
+  return 0;  
+} 
 int
 exec(char *path, char **argv)
 {
+    if(path_num == 0){
+     path_num = 1;
+     strncpy(path_set[0],"",1);
+  }
   char *s, *last;
-  int i, off;
+  char tmp[INPUT_BUF] = "";
+  int i, off,j,path_set_offset,path_offset;
   uint argc, sz, sp, ustack[3+MAXARG+1];
   struct elfhdr elf;
   struct inode *ip;
   struct proghdr ph;
   pde_t *pgdir, *oldpgdir;
+  j = 0 ;
+  path_offset = strlen(path);
 
-  if((ip = namei(path)) == 0)
+  do {
+  path_set_offset = strlen(path_set[j]);
+  strncpy(tmp,path_set[j],strlen(path_set[j]));
+  strncpy(tmp+path_set_offset ,path,path_offset);
+  tmp[strlen(tmp)]='\0'; 
+  j++;  
+  }while(((ip = namei(tmp)) == 0) && j<=path_num );
+  if(ip==0)
     return -1;
   ilock(ip);
   pgdir = 0;
-
   // Check ELF header
   if(readi(ip, (char*)&elf, 0, sizeof(elf)) < sizeof(elf))
     goto bad;
Index: sysproc.c
===================================================================
--- sysproc.c	(revision 3)
+++ sysproc.c	(working copy)
@@ -6,6 +6,14 @@
 #include "mmu.h"
 #include "proc.h"
 
+int 
+sys_addpath(void)
+{
+  char *path;
+   if(argstr(0, &path) < 0)
+    return -1;
+  return addpath(path);
+} 
 int
 sys_fork(void)
 {
@@ -26,6 +34,26 @@
 }
 
 int
+sys_wait2(void)
+{
+    int *wtime; 
+    if ((argptr(0, (void*)&wtime, sizeof(wtime))) <0) return -1;
+    int *rtime; 
+    if ((argptr(1, (void*)&rtime, sizeof(rtime))) <0) return -1;
+    int *iotime; 
+    if ((argptr(2, (void*)&iotime, sizeof(iotime))) <0) return -1;
+    return wait2(wtime,rtime,iotime);
+}
+
+int
+sys_getPriority(void)
+{
+   int *pid;
+   if((argptr(0,(void*) &pid,sizeof(&pid))) < 0) return -1;
+   return getPriority(pid);
+}
+
+int
 sys_kill(void)
 {
   int pid;
Index: param.h
===================================================================
--- param.h	(revision 3)
+++ param.h	(working copy)
@@ -9,4 +9,4 @@
 #define ROOTDEV       1  // device number of file system root disk
 #define MAXARG       32  // max exec arguments
 #define LOGSIZE      10  // max data sectors in on-disk log
-
+#define QUANTA      1
Index: export.c
===================================================================
--- export.c	(revision 0)
+++ export.c	(revision 0)
@@ -0,0 +1,31 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+  if(argc != 2 ){
+    printf(2, "Usage: addpath paths...\n");
+    exit();
+  }
+ 
+ char tmp[128] = "";
+ int j;
+ int k = 0;
+ for(j = 0; j < strlen(argv[1]) ; j++){
+   if(argv[1][j] == ':'){
+     tmp[k] = '\0';
+     if(addpath(tmp)<0){
+       printf(2, "addpath: %s failed to add paths\n", argv[1]);
+       break;
+     }  
+     k=0;
+   }
+   else{
+     tmp[k] = argv[1][j];
+     k++;
+   }
+ }
+  exit();
+}
\ No newline at end of file
Index: usys.S
===================================================================
--- usys.S	(revision 3)
+++ usys.S	(working copy)
@@ -29,3 +29,6 @@
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(addpath)
+SYSCALL(wait2)
+SYSCALL(getPriority)
\ No newline at end of file
Index: MLFQsanity.c
===================================================================
--- MLFQsanity.c	(revision 0)
+++ MLFQsanity.c	(revision 0)
@@ -0,0 +1,90 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+
+
+int
+main(int argc, char *argv[])
+{
+  int i;
+  int j;
+  int t;
+  int z;
+  int k;
+  int flag;
+  
+  int pidOfChild;
+  for (i=0;i<20;i++){
+    if ((flag=fork())==0){//child
+      if ((i%2)==0){
+	for(j=0; j<1000;j++){
+	  for (t=0;t<1000;t++){
+	      for (z=0;z<1000;z++){
+		k++;
+		k++;
+		k=z+j;
+	      }
+	   }
+         }
+      }
+      else{
+	sleep(1);
+      }
+	pidOfChild = getpid();
+	for (j=0;j<500;j++){
+	  printf(1,"child <%d> : cid: %d Prior %d prints for the <%d> time\n",pidOfChild,i,getPriority(&pidOfChild),j);
+	}
+	
+	exit();
+    }
+  }	
+  
+  if (flag!=0){//parent
+    int rtime,iotime,wtime;
+    int statistics[20][4];
+    int ind;
+    int pid;  
+    
+      for (ind=0;ind<20;ind++){
+	pid=wait2(&wtime,&rtime,&iotime);	 
+	statistics[ind][0] = wtime;
+	statistics[ind][1] = rtime;
+	statistics[ind][2] = wtime+rtime+iotime;
+	statistics[ind][3] = pid;
+	
+      }    
+    
+    int rTImeAvg=0;
+    int wTimeAvg=0;
+    int turnaroundTimeAvg=0;
+    for (ind=0;ind<20;ind++){
+	wTimeAvg = wTimeAvg+statistics[ind][0];
+	rTImeAvg = rTImeAvg+ statistics[ind][1];
+	turnaroundTimeAvg = turnaroundTimeAvg+ statistics[ind][2];
+    } 
+    rTImeAvg=rTImeAvg/20;
+    wTimeAvg=wTimeAvg/20;
+    turnaroundTimeAvg=turnaroundTimeAvg/20;
+    printf(1,"The requsted statistics are as follows: AvgWtime: %d, AvgRtime: %d, AvgTurnaroundTime: %d\n",wTimeAvg,rTImeAvg,turnaroundTimeAvg);
+       
+    
+       printf(1,"Even cid's: \n: ");
+       for (ind=0;ind<20;ind++){
+	    if (statistics[ind][3]%2==0){
+	    printf(1,"Pid is: %d Wtime: %d, Rtime: %d, TurnaroundTime: %d\n",statistics[ind][3],statistics[ind][0],statistics[ind][1],statistics[ind][2]);
+	    }   
+      }
+      printf(1,"Odd cid's: \n: ");
+       for (ind=0;ind<20;ind++){
+	    if (statistics[ind][3]%2==1){
+	    printf(1,"Pid is: %d Wtime: %d, Rtime: %d, TurnaroundTime: %d\n",statistics[ind][3],statistics[ind][0],statistics[ind][1],statistics[ind][2]);
+	    }   
+      }
+    
+  }
+    
+exit();
+  
+}
+
Index: Makefile
===================================================================
--- Makefile	(revision 3)
+++ Makefile	(working copy)
@@ -51,7 +51,7 @@
 endif
 
 # If the makefile can't find QEMU, specify its path here
-#QEMU = qemu-system-x86_64
+QEMU = qemu-system-x86_64
 
 # Try to infer the correct QEMU
 ifndef QEMU
@@ -67,6 +67,9 @@
 	echo "***" 1>&2; exit 1)
 endif
 
+#!
+SCHEDFLAG = DEFAULT
+
 CC = $(TOOLPREFIX)gcc
 AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
@@ -79,6 +82,10 @@
 # FreeBSD ld wants ``elf_i386_fbsd''
 LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null)
 
+
+CFLAGS += -D S_$(SCHEDFLAG)
+
+
 xv6.img: bootblock kernel fs.img
 	dd if=/dev/zero of=xv6.img count=10000
 	dd if=bootblock of=xv6.img conv=notrunc
@@ -146,7 +153,7 @@
 	$(OBJDUMP) -S _forktest > forktest.asm
 
 mkfs: mkfs.c fs.h
-	gcc -m32 -Werror -Wall -o mkfs mkfs.c
+	gcc -m32  -Wall -o mkfs mkfs.c
 
 UPROGS=\
 	_cat\
@@ -161,6 +168,11 @@
 	_sh\
 	_wc\
 	_zombie\
+	_export\
+	_FRRsanity\
+	_MLFQsanity\
+	_wait2test\
+	
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -230,7 +242,7 @@
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
-	printf.c umalloc.c\
+	printf.c umalloc.c export.c wait2test.c  FRRsanity.c MLFQsanity.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
Index: console.c
===================================================================
--- console.c	(revision 3)
+++ console.c	(working copy)
@@ -13,6 +13,7 @@
 #include "mmu.h"
 #include "proc.h"
 #include "x86.h"
+#include "defs.h"
 
 static void consputc(int);
 
@@ -124,6 +125,11 @@
 //PAGEBREAK: 50
 #define BACKSPACE 0x100
 #define CRTPORT 0x3d4
+#define KEY_UP          0xE2
+#define KEY_DN          0xE3
+#define KEY_LF          0xE4
+#define KEY_RT          0xE5
+
 static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
 
 static void
@@ -136,12 +142,20 @@
   pos = inb(CRTPORT+1) << 8;
   outb(CRTPORT, 15);
   pos |= inb(CRTPORT+1);
-
+  int curser=0;
   if(c == '\n')
     pos += 80 - pos%80;
   else if(c == BACKSPACE){
+    if(pos > 0) --pos;}
+  else if(c == KEY_LF){
     if(pos > 0) --pos;
-  } else
+    curser=1;
+  }
+  else if(c == KEY_RT){
+    ++pos;
+    curser=1;
+  }
+  else
     crt[pos++] = (c&0xff) | 0x0700;  // black on white
   
   if((pos/80) >= 24){  // Scroll up.
@@ -154,7 +168,9 @@
   outb(CRTPORT+1, pos>>8);
   outb(CRTPORT, 15);
   outb(CRTPORT+1, pos);
-  crt[pos] = ' ' | 0x0700;
+  if (curser==0){
+    crt[pos] = ' ' | 0x0700;
+  }
 }
 
 void
@@ -168,53 +184,231 @@
 
   if(c == BACKSPACE){
     uartputc('\b'); uartputc(' '); uartputc('\b');
-  } else
+  }
+  else if(c == KEY_LF){
+    uartputc('\b');}
+  else if(c == KEY_RT){
+    uartputc(' ');}
+  else
     uartputc(c);
   cgaputc(c);
 }
 
 #define INPUT_BUF 128
+#define MAX_HISTORY_LENGTH 20
+
 struct {
   struct spinlock lock;
   char buf[INPUT_BUF];
   uint r;  // Read index
   uint w;  // Write index
   uint e;  // Edit index
+  uint off; //Offset value
+  
 } input;
 
 #define C(x)  ((x)-'@')  // Control-x
 
+int historyPointer = 0;
+int historyOff = 0;
+char historyBuf[MAX_HISTORY_LENGTH][INPUT_BUF];
+
 void
 consoleintr(int (*getc)(void))
 {
   int c;
+ 
+  
 
+  /*cprintf("buf: %s\n",input.buf);
+  cprintf("Read index %d\n",input.r);
+  cprintf("Write index %d\n",input.w);
+  cprintf("Edit index %d\n",input.e);*/
   acquire(&input.lock);
   while((c = getc()) >= 0){
     switch(c){
     case C('P'):  // Process listing.
       procdump();
       break;
-    case C('U'):  // Kill line.
-      while(input.e != input.w &&
-            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
-        input.e--;
+    case C('U'):{  // Kill line.	
+	input.e=input.e+input.off;
+	while (input.off>0){
+	  consputc(KEY_RT);
+	  input.off--;
+	}
+	while(input.e!= input.w &&
+            input.buf[(input.e-1) % INPUT_BUF] != '\n'){        
+	input.e--;
         consputc(BACKSPACE);
       }
+      
+    }
       break;
     case C('H'): case '\x7f':  // Backspace
       if(input.e != input.w){
         input.e--;
-        consputc(BACKSPACE);
+        int i=0;  
+	while (i<input.off){	//move the offseted chars a step backward in the buffer
+	  input.buf[input.e+i % INPUT_BUF] = input.buf[input.e+i+1 % INPUT_BUF];
+	  i++;
+	}
+	consputc(BACKSPACE);
+	i=0;
+	while(i<input.off){ //print the moved offset
+	  consputc(input.buf[input.e+i]);
+	  i++;
+	}
+	i=0;
+	while(i<input.off){ //return curser to position
+	  consputc(KEY_LF);
+	  i++;
+	}
       }
       break;
+     case KEY_LF:  
+      if(input.e != input.w){
+        input.e--;
+	input.off++;
+        consputc(KEY_LF);
+      }
+      break;
+      case KEY_RT:  
+      if(input.off>0){
+        input.e++;
+	input.off--;
+        consputc(KEY_RT);
+      }
+      break;
+      case KEY_UP:
+
+	if (historyPointer>0){//to check if there is something even stored
+	  //store current buffer in a new spot on history buff:
+	  if (historyOff==0){
+	    int i=0;
+	    input.e=input.e+input.off;
+	    while ((i+input.r)<input.e){
+
+	      historyBuf[(historyPointer) % MAX_HISTORY_LENGTH][i]=input.buf[(i+input.r) % INPUT_BUF];
+	      i++;    
+	    }
+
+	    historyBuf[(historyPointer) % MAX_HISTORY_LENGTH][i]='\0';
+	    //cprintf("upbuf:%s\n",historyBuf[(historyPointer) % MAX_HISTORY_LENGTH]);
+	  }
+	  
+	  if (historyOff!=0) input.e=input.e+input.off;
+	  //delete whatever is on screen
+	  while (input.off>0){
+	  consputc(KEY_RT);
+	  input.off--;
+	  }
+	  while(input.e != input.w &&
+	    input.buf[(input.e-1) % INPUT_BUF] != '\n'){	  
+	    input.e--;
+	    consputc(BACKSPACE);
+	  }
+	  
+	  //reset buffer	  
+	  int i=0;
+	  for (i=0;i<128;i++){
+	    input.buf[i]='\0';
+	  }
+
+	  //fill buffer with previous command	  
+	  strncpy(input.buf,historyBuf[(historyPointer-1) % MAX_HISTORY_LENGTH],strlen(historyBuf[(historyPointer-1) % MAX_HISTORY_LENGTH])+1);
+	  
+	  input.buf[strlen(input.buf)-1]='\0';
+	  //print new line on screen
+	  i=0;
+	  while (input.buf[i]!='\0'){
+	    consputc(input.buf[i]);
+	    i++;
+	  }
+	  //fix indices
+	  input.r=0;
+	  input.e=strlen(input.buf);
+	  input.w=0;
+	  historyOff++;
+	  historyPointer--;
+	}
+	break;
+      case KEY_DN:
+	if (historyOff>0){//to check if there are down lines(only if moved up before)
+
+	  input.e=input.e+input.off;
+	  //delete whatever is on screen
+	  while (input.off>0){
+	  consputc(KEY_RT);
+	  input.off--;
+	  }	  
+	  while(input.e != input.w &&
+	    (input.buf[(input.e-1) % INPUT_BUF] != '\n'&&input.buf[(input.e-1) % INPUT_BUF] != '\0')){
+	    input.e--;
+	    consputc(BACKSPACE);
+	  }
+	  
+	  //reset buffer
+	  int i = 0;
+	  for (i=0;i<128;i++){
+	    input.buf[i]='\0';
+	  }
+
+	  //fill buffer with previous command	  
+	  strncpy(input.buf , historyBuf[(historyPointer+1) % MAX_HISTORY_LENGTH] , strlen(historyBuf[(historyPointer+1) % MAX_HISTORY_LENGTH]));
+
+	  input.buf[strlen(input.buf)-1]='\0';
+	  //print new line on screen
+	  //cprintf("newlineis:%s\n",input.buf);
+	  i=0;
+	  while (input.buf[i]!='\0'){
+	    consputc(input.buf[i]);
+	    i++;
+	  }
+	  //fix indices
+	  input.r=0;
+	  input.e=strlen(input.buf);
+	  input.w=0;
+	  historyOff--;
+	  historyPointer++;
+	}
+	break;
+      
     default:
-      if(c != 0 && input.e-input.r < INPUT_BUF){
-        c = (c == '\r') ? '\n' : c;
-        input.buf[input.e++ % INPUT_BUF] = c;
-        consputc(c);
+      if(c != 0 && input.e-input.r < INPUT_BUF){        
+	
+	c = (c == '\r') ? '\n' : c;
+	if(c == '\n' || c == C('D'))
+	  input.e = input.e + input.off; //fixing back the left movements
+	else{
+	  int i=input.off;  
+	  while (i>0){
+	    input.buf[input.e+i % INPUT_BUF] = input.buf[input.e+i-1 % INPUT_BUF];
+	    i--;
+	  }  
+	}
+	input.buf[input.e++ % INPUT_BUF] = c;
+	consputc(c);
+	int i=0; //printing the fixed line (if insertion was in the middle)
+	while(i<input.off){
+	  consputc(input.buf[input.e+i]);
+	  i++;
+	}
+	i=0; //returning the curser back to place
+	while(i<input.off){
+	  consputc(KEY_LF);
+	  i++;
+	}
         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
-          input.w = input.e;
+	  input.w = input.e;
+	  input.off = 0;
+	  //inserting row into memory:
+	  i=0;
+	  while ((i+input.r)<=input.w){
+	    historyBuf[historyPointer % MAX_HISTORY_LENGTH][i]=input.buf[(i+input.r) % INPUT_BUF];
+	    i++;    
+	  }
+	  historyBuf[historyPointer % MAX_HISTORY_LENGTH][i]='\0';
+	  historyPointer++;
           wakeup(&input.r);
         }
       }
@@ -289,5 +483,4 @@
 
   picenable(IRQ_KBD);
   ioapicenable(IRQ_KBD, 0);
-}
-
+}
\ No newline at end of file
Index: proc.c
===================================================================
--- proc.c	(revision 3)
+++ proc.c	(working copy)
@@ -6,8 +6,71 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
-#include "signal.h"
+#define QUEUE_SIZE (NPROC)
+//Elements required for FRR
 
+struct proc* procQueue[QUEUE_SIZE];
+int qIn = 0;
+int qOut = 0;
+
+void QueuePut(struct proc* p) {
+ procQueue[qIn] = p;
+ qIn = (qIn + 1) % QUEUE_SIZE; 
+}
+
+struct proc* QueueGet(){
+ struct proc* res =  procQueue[qOut];
+ qOut = (qOut + 1) % QUEUE_SIZE;
+ return res;
+}
+
+struct proc* procQueue1[QUEUE_SIZE];
+int qIn1 = 0;
+int qOut1 = 0;
+
+void QueuePut1(struct proc* p) {
+ procQueue1[qIn1] = p;
+ qIn1 = (qIn1 + 1) % QUEUE_SIZE;
+}
+
+struct proc* QueueGet1(){
+ struct proc* res =  procQueue1[qOut1];
+ qOut1 = (qOut1 + 1) % QUEUE_SIZE;
+ 
+ return res;
+}
+
+
+struct proc* procQueue2[QUEUE_SIZE];
+int qIn2 = 0;
+int qOut2 = 0;
+
+void QueuePut2(struct proc* p) {
+ procQueue2[qIn2] = p;
+ qIn2 = (qIn2 + 1) % QUEUE_SIZE;
+}
+
+struct proc* QueueGet2(){
+ struct proc* res =  procQueue2[qOut2];
+ qOut2 = (qOut2 + 1) % QUEUE_SIZE;
+ return res;
+}
+
+struct proc* procQueue3[QUEUE_SIZE];
+int qIn3 = 0;
+int qOut3 = 0;
+
+void QueuePut3(struct proc* p) {
+ procQueue3[qIn3] = p;
+ qIn3 = (qIn3 + 1) % QUEUE_SIZE;
+}
+
+struct proc* QueueGet3(){
+ struct proc* res =  procQueue3[qOut3];
+ qOut3 = (qOut3 + 1) % QUEUE_SIZE;
+ return res;
+}
+
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
@@ -27,6 +90,18 @@
   initlock(&ptable.lock, "ptable");
 }
 
+void
+updateproc(){
+    struct proc *p;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == SLEEPING){
+      p->iotime ++;
+    }
+   if(p->state == RUNNING){
+      p->rtime ++;
+    }
+    }
+}
 //PAGEBREAK: 32
 // Look in the process table for an UNUSED proc.
 // If found, change state to EMBRYO and initialize
@@ -37,7 +112,9 @@
 {
   struct proc *p;
   char *sp;
-
+ // cprintf("allocproc");
+  
+  
   acquire(&ptable.lock);
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
     if(p->state == UNUSED)
@@ -46,8 +123,13 @@
   return 0;
 
 found:
+  p->quanta = 0;
+  p->ctime = ticks;
+  p->rtime = 0;
+  p->iotime = 0;
   p->state = EMBRYO;
   p->pid = nextpid++;
+  p->priority = 2;
   release(&ptable.lock);
 
   // Allocate kernel stack.
@@ -81,7 +163,6 @@
 {
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
-  
   p = allocproc();
   initproc = p;
   if((p->pgdir = setupkvm(kalloc)) == 0)
@@ -99,8 +180,19 @@
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
-
   p->state = RUNNABLE;
+  #if defined(S_FRR)
+  QueuePut(p);  
+  #endif
+  
+  #if defined(S_FCFS)
+  QueuePut(p);  
+  #endif
+  
+  #if defined(S_3Q)
+  
+  QueuePut2(p);
+  #endif
 }
 
 // Grow current process's memory by n bytes.
@@ -157,6 +249,23 @@
  
   pid = np->pid;
   np->state = RUNNABLE;
+  #if defined(S_FRR)
+  QueuePut(np);  
+  #endif
+  
+  #if defined(S_FCFS)
+  QueuePut(np);  
+  #endif
+  
+   #if defined(S_3Q)
+   np->priority=2;
+   int prior = np->priority;   
+   if (prior==1) QueuePut1(np);
+   else if (prior==2) QueuePut2(np);
+   else if (prior==3) QueuePut3(np);  
+   #endif  
+  
+  
   safestrcpy(np->name, proc->name, sizeof(proc->name));
   return pid;
 }
@@ -164,12 +273,11 @@
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
-void
-exit(void)
+void exit(void)
 {
   struct proc *p;
   int fd;
-
+ 
   if(proc == initproc)
     panic("init exiting");
 
@@ -183,7 +291,7 @@
 
   iput(proc->cwd);
   proc->cwd = 0;
-
+  proc->etime = ticks;
   acquire(&ptable.lock);
 
   // Parent might be sleeping in wait().
@@ -203,12 +311,12 @@
   sched();
   panic("zombie exit");
 }
-
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
 int
 wait(void)
 {
+  //cprintf("wait");
   struct proc *p;
   int havekids, pid;
 
@@ -247,9 +355,67 @@
   }
 }
 
+int
+getPriority(int* pid){
+  struct proc *p;
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){//scan table for pid
+      if (*pid == p->pid){
+      release(&ptable.lock);
+      return p->priority; }   
+  }
+  release(&ptable.lock);
+  return 0; 
+}
+
+int
+wait2(int* wtime,int* rtime,int* iotime)
+{
+  //cprintf("wait2");
+  struct proc *p;
+  int havekids, pid;
+
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != proc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->state = UNUSED;
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        *wtime= (p->etime - p->ctime) - (p->rtime + p->iotime);
+        *rtime = p->rtime;
+	*iotime = p->iotime;
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || proc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+  }
+}
 void
 register_handler(sighandler_t sighandler)
 {
+  //cprintf("handler");
   char* addr = uva2ka(proc->pgdir, (char*)proc->tf->esp);
   if ((proc->tf->esp & 0xFFF) == 0)
     panic("esp_offset == 0");
@@ -275,14 +441,17 @@
 void
 scheduler(void)
 {
-  struct proc *p;
+  
 
   for(;;){
     // Enable interrupts on this processor.
     sti();
-
+     
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
+    
+     #if defined(S_DEFAULT)
+    struct proc *p;
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->state != RUNNABLE)
         continue;
@@ -300,16 +469,111 @@
       // It should have changed its p->state before coming back.
       proc = 0;
     }
+    
+    #endif
+    
+   #if defined(S_FRR)
+   struct proc *p;
+      
+      if(qIn==qOut){
+	
+	release(&ptable.lock);
+	continue;
+      }
+    else{
+      p = QueueGet(); 
+      
+      proc = p;
+      
+      switchuvm(p);
+      
+      p->state = RUNNING;
+      
+      swtch(&cpu->scheduler, proc->context);
+      switchkvm();
+      
+      // Process is done running for now.
+      // It should have changed its p->state before coming back.
+      proc = 0;
+    
+      }
+    #endif
+    
+     #if defined(S_FCFS)
+      struct proc *p;     
+      if(qIn==qOut){
+	release(&ptable.lock);
+	continue;
+      }
+    else{
+      p = QueueGet(); 
+      proc = p;
+      switchuvm(p);
+      p->state = RUNNING;
+      swtch(&cpu->scheduler, proc->context);
+      switchkvm();
+      // Process is done running for now.
+      // It should have changed its p->state before coming back.
+      proc = 0;
+    
+      }
+   #endif
+   
+    #if defined(S_3Q)
+     struct proc *p;
+     if(qIn1 != qOut1){
+	p = QueueGet1();
+	proc = p;
+	switchuvm(p);
+	p->state = RUNNING;
+	swtch(&cpu->scheduler, proc->context);
+	switchkvm();
+	// Process is done running for now.
+	// It should have changed its p->state before coming back.
+	proc = 0;
+     }
+     
+     else if(qIn2 != qOut2){
+       	p = QueueGet2();
+	proc = p;
+	switchuvm(p);
+	p->state = RUNNING;
+	swtch(&cpu->scheduler, proc->context);
+	switchkvm();
+	// Process is done running for now.
+	// It should have changed its p->state before coming back.
+	proc = 0;
+     }
+     
+     else if(qIn3 != qOut3){   
+       	p = QueueGet3();
+	proc = p;
+	switchuvm(p);
+	p->state = RUNNING;
+	swtch(&cpu->scheduler, proc->context);
+	switchkvm();
+	
+	// Process is done running for now.
+	// It should have changed its p->state before coming back.
+	proc = 0;
+     }     
+     
+     else{
+       	release(&ptable.lock);
+	continue;
+     }
+     
+    #endif
     release(&ptable.lock);
 
   }
 }
-
 // Enter scheduler.  Must hold only ptable.lock
 // and have changed proc->state.
 void
 sched(void)
 {
+  //cprintf("sched2");
   int intena;
 
   if(!holding(&ptable.lock))
@@ -331,11 +595,31 @@
 {
   acquire(&ptable.lock);  //DOC: yieldlock
   proc->state = RUNNABLE;
+  #if defined(S_FRR)
+  QueuePut(proc);  
+  #endif
+  
+  #if defined(S_FCFS)
+  QueuePut(proc);  
+  #endif
+  
+  #if defined(S_3Q)
+  if( (proc->quanta % QUANTA == 0)  && (proc-> priority != 3)){
+    proc-> priority++;
+  }
+ 
+  if(proc->priority == 1) QueuePut1(proc); 
+  else if(proc -> priority == 2) QueuePut2(proc);
+  else  QueuePut3(proc);
+   
+  #endif
   sched();
   release(&ptable.lock);
 }
 
-// A fork child's very first scheduling by scheduler()
+// A fork child's very first 
+
+//ling by scheduler()
 // will swtch here.  "Return" to user space.
 void
 forkret(void)
@@ -380,6 +664,7 @@
   // Go to sleep.
   proc->chan = chan;
   proc->state = SLEEPING;
+  proc->quanta = 0;
   sched();
 
   // Tidy up.
@@ -400,9 +685,25 @@
 {
   struct proc *p;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->state == SLEEPING && p->chan == chan)
+    {
       p->state = RUNNABLE;
+       p->quanta=0;
+      #if defined(S_FRR)
+      QueuePut(p);  
+      #endif
+      #if defined(S_FCFS)
+      QueuePut(p);  
+      #endif      
+      #if defined(S_3Q)
+      if(p->priority != 1) p->priority--;
+      if(p->priority == 1) QueuePut1(p);
+      else if(p->priority ==2) QueuePut2(p);
+      else QueuePut3(p);
+      #endif
+    }
+  } 
 }
 
 // Wake up all processes sleeping on chan.
@@ -426,12 +727,31 @@
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->pid == pid){
       p->killed = 1;
+      p->etime =  ticks;
+      p->quanta = 0;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if(p->state == SLEEPING){
         p->state = RUNNABLE;
+      }
+      	#if defined(S_FRR)
+	QueuePut(p);
+	#endif
+	
+      	#if defined(S_FCFS)
+	QueuePut(p);
+	#endif
+	
+	#if defined(S_3Q)
+	if(p->priority != 1) p->priority--;
+	if(p->priority == 1) QueuePut1(p);
+	else if(p->priority ==2) QueuePut2(p);
+	else QueuePut3(p);
+	#endif	
+	
       release(&ptable.lock);
       return 0;
     }
+    
   }
   release(&ptable.lock);
   return -1;
@@ -472,6 +792,7 @@
     }
     cprintf("\n");
   }
+  
 }
 
 
Index: trap.c
===================================================================
--- trap.c	(revision 3)
+++ trap.c	(working copy)
@@ -51,6 +51,7 @@
     if(cpu->id == 0){
       acquire(&tickslock);
       ticks++;
+      updateproc();
       wakeup(&ticks);
       release(&tickslock);
     }
@@ -102,9 +103,26 @@
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
-    yield();
-
+  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER){
+          int bol=1;
+	#if defined(S_FCFS)
+	bol=0;
+	#endif
+	#if defined(S_DEFAULT)||defined(S_FRR)
+	if (proc->quanta%QUANTA==0) bol=1;
+	else bol=0;  
+	#endif
+	#if defined(S_3Q)
+	if(proc->priority == 3){
+	      bol = 0;
+	}
+	else{
+	    	if (proc->quanta%QUANTA==0) bol=1;
+		else bol=0;  
+	}
+	 #endif
+	 if (bol==1) yield();
+  }
   // Check if the process has been killed since we yielded
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
     exit();
Index: proc.h
===================================================================
--- proc.h	(revision 3)
+++ proc.h	(working copy)
@@ -51,6 +51,8 @@
 
 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
+typedef void (*sighandler_t)(void);
+
 // Per-process state
 struct proc {
   uint sz;                     // Size of process memory (bytes)
@@ -66,6 +68,12 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  uint ctime;
+  uint etime;
+  int iotime;
+  int rtime;
+  int quanta;
+  int priority;
 };
 
 // Process memory is laid out contiguously, low addresses first:
Index: defs.h
===================================================================
--- defs.h	(revision 3)
+++ defs.h	(working copy)
@@ -22,7 +22,9 @@
 
 // exec.c
 int             exec(char*, char**);
-
+extern char   path_set[10][128];
+extern int path_num;
+int              addpath(char* path);
 // file.c
 struct file*    filealloc(void);
 void            fileclose(struct file*);
@@ -114,8 +116,11 @@
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
 int             wait(void);
+int             wait2(int*,int*,int*);
 void            wakeup(void*);
 void            yield(void);
+void            updateproc();
+int		getPriority(int*);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
Index: FRRsanity.c
===================================================================
--- FRRsanity.c	(revision 0)
+++ FRRsanity.c	(revision 0)
@@ -0,0 +1,37 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+  int bol = 1,i,j;
+  
+  if(bol!=0){
+  for(i = 0; i<10  ; i++){
+    if(bol!= 0)
+    bol= fork();
+    }}
+  if(bol==0){    
+    for(j = 0; j < 1000; j++){
+    printf(1,"child %d prints for the %d time\n",getpid(),j);
+      }
+    exit(); 
+  }
+  if(bol!=0){
+  int wtime,rtime,iotime;
+  int childStats[10][3];
+  for(i =0 ; i< 10; i++){
+    wait2(&wtime,&rtime,&iotime);
+    childStats[i][0] = wtime;
+    childStats[i][1] = rtime;
+    childStats[i][2] = wtime + rtime + iotime;
+  }
+  
+  for (i = 0; i < 10; i++){
+     printf(1,"wait time = %d run time = %d turnaround time = %d\n",childStats[i][0],childStats[i][1],childStats[i][2]);   
+  }
+ }
+ 
+ exit();
+}
Index: user.h
===================================================================
--- user.h	(revision 3)
+++ user.h	(working copy)
@@ -22,6 +22,9 @@
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int addpath(char*);
+int wait2(int *, int *,int *);
+int getPriority(int*);
 
 // ulib.c
 int stat(char*, struct stat*);
Index: wait2test.c
===================================================================
--- wait2test.c	(revision 0)
+++ wait2test.c	(revision 0)
@@ -0,0 +1,55 @@
+// Test that fork fails gracefully.
+// Tiny executable so that the limit can be filling the proc table.
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#define N  1000
+/*
+void
+printf(int fd, char *s, ...)
+{
+  write(fd, s, strlen(s));
+}
+*/
+
+void
+foo()
+{
+  int i;
+  for (i=0;i<100;i++)
+     printf(2, "wait test %d\n",i);
+  sleep(20);
+  for (i=0;i<100;i++)
+     printf(2, "wait test %d\n",i);
+
+}
+
+void
+waittest(void)
+{
+  int wTime;
+  int rTime;
+  int ioTime;
+  int pid;
+  printf(1, "wait test\n");
+
+
+    pid = fork();
+    if(pid == 0)
+    {
+      foo();
+      exit();      
+    }
+    wait2(&wTime,&rTime,&ioTime);
+     printf(1, "hi \n");
+    printf(1, "wTime: %d rTime: %d ioTime: %d \n",wTime,rTime, ioTime);
+
+}
+int
+main(void)
+{
+  waittest();
+  exit();
+} 
\ No newline at end of file
