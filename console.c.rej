--- console.c	(revision 3)
+++ console.c	(working copy)
@@ -13,6 +13,7 @@
 #include "mmu.h"
 #include "proc.h"
 #include "x86.h"
+#include "defs.h"
 
 static void consputc(int);
 
@@ -124,6 +125,11 @@
 //PAGEBREAK: 50
 #define BACKSPACE 0x100
 #define CRTPORT 0x3d4
+#define KEY_UP          0xE2
+#define KEY_DN          0xE3
+#define KEY_LF          0xE4
+#define KEY_RT          0xE5
+
 static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
 
 static void
@@ -136,12 +142,20 @@
   pos = inb(CRTPORT+1) << 8;
   outb(CRTPORT, 15);
   pos |= inb(CRTPORT+1);
-
+  int curser=0;
   if(c == '\n')
     pos += 80 - pos%80;
   else if(c == BACKSPACE){
+    if(pos > 0) --pos;}
+  else if(c == KEY_LF){
     if(pos > 0) --pos;
-  } else
+    curser=1;
+  }
+  else if(c == KEY_RT){
+    ++pos;
+    curser=1;
+  }
+  else
     crt[pos++] = (c&0xff) | 0x0700;  // black on white
   
   if((pos/80) >= 24){  // Scroll up.
@@ -154,7 +168,9 @@
   outb(CRTPORT+1, pos>>8);
   outb(CRTPORT, 15);
   outb(CRTPORT+1, pos);
-  crt[pos] = ' ' | 0x0700;
+  if (curser==0){
+    crt[pos] = ' ' | 0x0700;
+  }
 }
 
 void
@@ -168,53 +184,231 @@
 
   if(c == BACKSPACE){
     uartputc('\b'); uartputc(' '); uartputc('\b');
-  } else
+  }
+  else if(c == KEY_LF){
+    uartputc('\b');}
+  else if(c == KEY_RT){
+    uartputc(' ');}
+  else
     uartputc(c);
   cgaputc(c);
 }
 
 #define INPUT_BUF 128
+#define MAX_HISTORY_LENGTH 20
+
 struct {
   struct spinlock lock;
   char buf[INPUT_BUF];
   uint r;  // Read index
   uint w;  // Write index
   uint e;  // Edit index
+  uint off; //Offset value
+  
 } input;
 
 #define C(x)  ((x)-'@')  // Control-x
 
+int historyPointer = 0;
+int historyOff = 0;
+char historyBuf[MAX_HISTORY_LENGTH][INPUT_BUF];
+
 void
 consoleintr(int (*getc)(void))
 {
   int c;
+ 
+  
 
+  /*cprintf("buf: %s\n",input.buf);
+  cprintf("Read index %d\n",input.r);
+  cprintf("Write index %d\n",input.w);
+  cprintf("Edit index %d\n",input.e);*/
   acquire(&input.lock);
   while((c = getc()) >= 0){
     switch(c){
     case C('P'):  // Process listing.
       procdump();
       break;
-    case C('U'):  // Kill line.
-      while(input.e != input.w &&
-            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
-        input.e--;
+    case C('U'):{  // Kill line.	
+	input.e=input.e+input.off;
+	while (input.off>0){
+	  consputc(KEY_RT);
+	  input.off--;
+	}
+	while(input.e!= input.w &&
+            input.buf[(input.e-1) % INPUT_BUF] != '\n'){        
+	input.e--;
         consputc(BACKSPACE);
       }
+      
+    }
       break;
     case C('H'): case '\x7f':  // Backspace
       if(input.e != input.w){
         input.e--;
-        consputc(BACKSPACE);
+        int i=0;  
+	while (i<input.off){	//move the offseted chars a step backward in the buffer
+	  input.buf[input.e+i % INPUT_BUF] = input.buf[input.e+i+1 % INPUT_BUF];
+	  i++;
+	}
+	consputc(BACKSPACE);
+	i=0;
+	while(i<input.off){ //print the moved offset
+	  consputc(input.buf[input.e+i]);
+	  i++;
+	}
+	i=0;
+	while(i<input.off){ //return curser to position
+	  consputc(KEY_LF);
+	  i++;
+	}
       }
       break;
+     case KEY_LF:  
+      if(input.e != input.w){
+        input.e--;
+	input.off++;
+        consputc(KEY_LF);
+      }
+      break;
+      case KEY_RT:  
+      if(input.off>0){
+        input.e++;
+	input.off--;
+        consputc(KEY_RT);
+      }
+      break;
+      case KEY_UP:
+
+	if (historyPointer>0){//to check if there is something even stored
+	  //store current buffer in a new spot on history buff:
+	  if (historyOff==0){
+	    int i=0;
+	    input.e=input.e+input.off;
+	    while ((i+input.r)<input.e){
+
+	      historyBuf[(historyPointer) % MAX_HISTORY_LENGTH][i]=input.buf[(i+input.r) % INPUT_BUF];
+	      i++;    
+	    }
+
+	    historyBuf[(historyPointer) % MAX_HISTORY_LENGTH][i]='\0';
+	    //cprintf("upbuf:%s\n",historyBuf[(historyPointer) % MAX_HISTORY_LENGTH]);
+	  }
+	  
+	  if (historyOff!=0) input.e=input.e+input.off;
+	  //delete whatever is on screen
+	  while (input.off>0){
+	  consputc(KEY_RT);
+	  input.off--;
+	  }
+	  while(input.e != input.w &&
+	    input.buf[(input.e-1) % INPUT_BUF] != '\n'){	  
+	    input.e--;
+	    consputc(BACKSPACE);
+	  }
+	  
+	  //reset buffer	  
+	  int i=0;
+	  for (i=0;i<128;i++){
+	    input.buf[i]='\0';
+	  }
+
+	  //fill buffer with previous command	  
+	  strncpy(input.buf,historyBuf[(historyPointer-1) % MAX_HISTORY_LENGTH],strlen(historyBuf[(historyPointer-1) % MAX_HISTORY_LENGTH])+1);
+	  
+	  input.buf[strlen(input.buf)-1]='\0';
+	  //print new line on screen
+	  i=0;
+	  while (input.buf[i]!='\0'){
+	    consputc(input.buf[i]);
+	    i++;
+	  }
+	  //fix indices
+	  input.r=0;
+	  input.e=strlen(input.buf);
+	  input.w=0;
+	  historyOff++;
+	  historyPointer--;
+	}
+	break;
+      case KEY_DN:
+	if (historyOff>0){//to check if there are down lines(only if moved up before)
+
+	  input.e=input.e+input.off;
+	  //delete whatever is on screen
+	  while (input.off>0){
+	  consputc(KEY_RT);
+	  input.off--;
+	  }	  
+	  while(input.e != input.w &&
+	    (input.buf[(input.e-1) % INPUT_BUF] != '\n'&&input.buf[(input.e-1) % INPUT_BUF] != '\0')){
+	    input.e--;
+	    consputc(BACKSPACE);
+	  }
+	  
+	  //reset buffer
+	  int i = 0;
+	  for (i=0;i<128;i++){
+	    input.buf[i]='\0';
+	  }
+
+	  //fill buffer with previous command	  
+	  strncpy(input.buf , historyBuf[(historyPointer+1) % MAX_HISTORY_LENGTH] , strlen(historyBuf[(historyPointer+1) % MAX_HISTORY_LENGTH]));
+
+	  input.buf[strlen(input.buf)-1]='\0';
+	  //print new line on screen
+	  //cprintf("newlineis:%s\n",input.buf);
+	  i=0;
+	  while (input.buf[i]!='\0'){
+	    consputc(input.buf[i]);
+	    i++;
+	  }
+	  //fix indices
+	  input.r=0;
+	  input.e=strlen(input.buf);
+	  input.w=0;
+	  historyOff--;
+	  historyPointer++;
+	}
+	break;
+      
     default:
-      if(c != 0 && input.e-input.r < INPUT_BUF){
-        c = (c == '\r') ? '\n' : c;
-        input.buf[input.e++ % INPUT_BUF] = c;
-        consputc(c);
+      if(c != 0 && input.e-input.r < INPUT_BUF){        
+	
+	c = (c == '\r') ? '\n' : c;
+	if(c == '\n' || c == C('D'))
+	  input.e = input.e + input.off; //fixing back the left movements
+	else{
+	  int i=input.off;  
+	  while (i>0){
+	    input.buf[input.e+i % INPUT_BUF] = input.buf[input.e+i-1 % INPUT_BUF];
+	    i--;
+	  }  
+	}
+	input.buf[input.e++ % INPUT_BUF] = c;
+	consputc(c);
+	int i=0; //printing the fixed line (if insertion was in the middle)
+	while(i<input.off){
+	  consputc(input.buf[input.e+i]);
+	  i++;
+	}
+	i=0; //returning the curser back to place
+	while(i<input.off){
+	  consputc(KEY_LF);
+	  i++;
+	}
         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
-          input.w = input.e;
+	  input.w = input.e;
+	  input.off = 0;
+	  //inserting row into memory:
+	  i=0;
+	  while ((i+input.r)<=input.w){
+	    historyBuf[historyPointer % MAX_HISTORY_LENGTH][i]=input.buf[(i+input.r) % INPUT_BUF];
+	    i++;    
+	  }
+	  historyBuf[historyPointer % MAX_HISTORY_LENGTH][i]='\0';
+	  historyPointer++;
           wakeup(&input.r);
         }
       }
@@ -289,5 +483,4 @@
 
   picenable(IRQ_KBD);
   ioapicenable(IRQ_KBD, 0);
-}
-
+}